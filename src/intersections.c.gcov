        -:    0:Source:/Users/standard/Desktop/Projects/raytracer/raytracer/src/intersections.c
        -:    0:Graph:../build/CMakeFiles/main_lib.dir/src/intersections.c.gcno
        -:    0:Data:../build/CMakeFiles/main_lib.dir/src/intersections.c.gcda
        -:    0:Runs:1
        -:    1:// intersections.c
        -:    2:
        -:    3:#include "../include/intersections.h"
        -:    4:#include "../include/shapes.h"
        -:    5:#include <stdarg.h>
        -:    6:#include <stdio.h>
        -:    7:#include <stdlib.h>
        -:    8:
      332:    9:intersection_t intersection(double t, void *o)
        -:   10:{
      332:   11:    intersection_t i = {0};
      332:   12:    i.t              = t;
      332:   13:    i.object         = o;
      332:   14:    return i;
        -:   15:}
        -:   16:
        5:   17:intersection_t intersection_with_uv(double t, void *o, double u, double v)
        -:   18:{
        5:   19:    intersection_t i = {0};
        5:   20:    i.t              = t;
        5:   21:    i.object         = o;
        5:   22:    i.u              = u;
        5:   23:    i.v              = v;
        5:   24:    return i;
        -:   25:}
        -:   26:
       14:   27:intersections_t intersections(int count, ...)
        -:   28:{
       14:   29:    va_list args;
       14:   30:    va_start(args, count);
        -:   31:
        -:   32:    intersections_t result;
       14:   33:    result.count = count;
        -:   34:
       47:   35:    for (int i = 0; i < count; i++)
        -:   36:    {
       33:   37:        result.intersections[i] = va_arg(args, intersection_t);
       33:   38:    }
        -:   39:
       14:   40:    va_end(args);
        -:   41:
        -:   42:    return result;
       14:   43:}
        -:   44:
      235:   45:intersection_t *intersections_hit(const intersections_t *xs)
        -:   46:{
      235:   47:    if (xs == NULL)
        -:   48:    {
    #####:   49:        return NULL;
        -:   50:    }
        -:   51:
      235:   52:    intersection_t *hit = NULL;
        -:   53:
      517:   54:    for (int i = 0; i < xs->count; i++)
        -:   55:    {
      282:   56:        if (xs->intersections[i].t >= 0)
        -:   57:        {
      165:   58:            if (hit == NULL || xs->intersections[i].t < hit->t)
        -:   59:            {
       80:   60:                hit = (intersection_t *)&xs->intersections[i];
       80:   61:            }
      165:   62:        }
      282:   63:    }
        -:   64:
      235:   65:    return hit;
      235:   66:}
        -:   67:
       44:   68:computations_t intersections_prepare_computations(const intersection_t *i,
        -:   69:                                                  const ray_t *r,
        -:   70:                                                  const intersections_t *xs)
        -:   71:{
       44:   72:    computations_t comps = {0};
        -:   73:
       44:   74:    if (i == NULL || r == NULL)
        -:   75:    {
    #####:   76:        return comps;
        -:   77:    }
        -:   78:
       44:   79:    comps.t      = i->t;
       44:   80:    comps.object = i->object;
       44:   81:    comps.point  = ray_position(*r, comps.t);
       44:   82:    comps.eyev   = tuple_negate(r->direction);
       44:   83:    comps.normalv =
       44:   84:        shape_normal_at((const shape_t *)comps.object, comps.point, i);
       44:   85:    comps.reflectv = tuple_reflect(r->direction, comps.normalv);
        -:   86:
       44:   87:    if (tuple_dot(comps.normalv, comps.eyev) < 0)
        -:   88:    {
       12:   89:        comps.inside  = true;
       12:   90:        comps.normalv = tuple_negate(comps.normalv);
       12:   91:    }
        -:   92:    else
        -:   93:    {
       32:   94:        comps.inside = false;
        -:   95:    }
        -:   96:
       44:   97:    comps.over_point =
       44:   98:        tuple_add(comps.point, tuple_scale(comps.normalv, EPSILON));
       44:   99:    comps.under_point =
       44:  100:        tuple_subtract(comps.point, tuple_scale(comps.normalv, EPSILON));
        -:  101:
       44:  102:    comps.n1 = 1.0;
       44:  103:    comps.n2 = 1.0;
        -:  104:
       44:  105:    if (xs != NULL)
        -:  106:    {
       33:  107:        int containers_count = 0;
       33:  108:        shape_t *containers[MAX_INTERSECTIONS];
        -:  109:
      100:  110:        for (int j = 0; j < xs->count; j++)
        -:  111:        {
        -:  112:
      100:  113:            bool is_hit = (equal(xs->intersections[j].t, i->t) &&
       33:  114:                           xs->intersections[j].object == i->object);
        -:  115:
       67:  116:            if (is_hit)
        -:  117:            {
       33:  118:                if (containers_count == 0)
        -:  119:                {
       12:  120:                    comps.n1 = 1.0;
       12:  121:                }
        -:  122:                else
        -:  123:                {
        -:  124:
       42:  125:                    shape_t *containing_object =
       21:  126:                        containers[containers_count - 1];
       21:  127:                    comps.n1 = containing_object->material.refractive_index;
       21:  128:                }
       33:  129:            }
        -:  130:
       67:  131:            int object_index = -1;
      112:  132:            for (int k = 0; k < containers_count; k++)
        -:  133:            {
       45:  134:                if (containers[k] == (shape_t *)xs->intersections[j].object)
        -:  135:                {
       11:  136:                    object_index = k;
       11:  137:                    break;
        -:  138:                }
       34:  139:            }
        -:  140:
       67:  141:            if (object_index >= 0)
        -:  142:            {
       11:  143:                if (object_index < containers_count - 1)
        -:  144:                {
        3:  145:                    containers[object_index] = containers[containers_count - 1];
        3:  146:                }
       11:  147:                containers_count--;
       11:  148:            }
        -:  149:            else
        -:  150:            {
        -:  151:
       56:  152:                containers[containers_count] =
       56:  153:                    (shape_t *)xs->intersections[j].object;
       56:  154:                containers_count++;
        -:  155:            }
        -:  156:
       67:  157:            if (is_hit)
        -:  158:            {
       33:  159:                if (containers_count == 0)
        -:  160:                {
        4:  161:                    comps.n2 = 1.0;
        4:  162:                }
        -:  163:                else
        -:  164:                {
        -:  165:
       58:  166:                    shape_t *containing_object =
       29:  167:                        containers[containers_count - 1];
       29:  168:                    comps.n2 = containing_object->material.refractive_index;
       29:  169:                }
       33:  170:                break;
        -:  171:            }
       67:  172:        }
       33:  173:    }
        -:  174:
       44:  175:    return comps;
       44:  176:}
        -:  177:
        3:  178:double intersections_shlick(const computations_t *c)
        -:  179:{
        3:  180:    if (c == NULL)
        -:  181:    {
    #####:  182:        return 0.0;
        -:  183:    }
        -:  184:
        3:  185:    double cos = tuple_dot(c->eyev, c->normalv);
        -:  186:
        3:  187:    if (c->n1 > c->n2)
        -:  188:    {
        2:  189:        double n      = c->n1 / c->n2;
        2:  190:        double sin2_t = (n * n) * (1.0 - cos * cos);
        -:  191:
        2:  192:        if (sin2_t > 1.0)
        -:  193:        {
        1:  194:            return 1.0;
        -:  195:        }
        -:  196:
        1:  197:        double cos_t = sqrt(1.0 - sin2_t);
        1:  198:        cos          = cos_t;
        2:  199:    }
        -:  200:
        4:  201:    double r0 = ((c->n1 - c->n2) / (c->n1 + c->n2)) *
        2:  202:                ((c->n1 - c->n2) / (c->n1 + c->n2));
        -:  203:
        4:  204:    return r0 + (1 - r0) *
        2:  205:                    ((1 - cos) * (1 - cos) * (1 - cos) * (1 - cos) * (1 - cos));
        3:  206:}
        -:  207:
    #####:  208:static int compare_intersections(const void *a, const void *b)
        -:  209:{
    #####:  210:    const intersection_t *ia = (const intersection_t *)a;
    #####:  211:    const intersection_t *ib = (const intersection_t *)b;
        -:  212:
    #####:  213:    if (ia->t < ib->t)
    #####:  214:        return -1;
    #####:  215:    if (ia->t > ib->t)
    #####:  216:        return 1;
    #####:  217:    return 0;
    #####:  218:}
        -:  219:
       80:  220:static void insertion_sort_intersections(intersection_t *xs, int count)
        -:  221:{
      228:  222:    for (int i = 1; i < count; i++)
        -:  223:    {
      148:  224:        intersection_t key = xs[i];
      148:  225:        int j              = i - 1;
        -:  226:
      234:  227:        while (j >= 0 && xs[j].t > key.t)
        -:  228:        {
       86:  229:            xs[j + 1] = xs[j];
       86:  230:            j--;
        -:  231:        }
      148:  232:        xs[j + 1] = key;
      148:  233:    }
       80:  234:}
        -:  235:
       80:  236:void intersections_sort(intersections_t *xs)
        -:  237:{
       80:  238:    if (xs == NULL || xs->count <= 1)
        -:  239:    {
    #####:  240:        return;
        -:  241:    }
        -:  242:
       80:  243:    if (xs->count <= 20)
        -:  244:    {
       80:  245:        insertion_sort_intersections(xs->intersections, xs->count);
       80:  246:    }
        -:  247:    else
        -:  248:    {
    #####:  249:        qsort(xs->intersections, (size_t)xs->count, sizeof(intersection_t),
        -:  250:              compare_intersections);
        -:  251:    }
       80:  252:}
